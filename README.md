
# Сервис динамического сегментирования пользователей
## Техническое задание
### Задача:

Требуется реализовать сервис, хранящий пользователя и сегменты, в которых он состоит (создание, изменение, удаление сегментов, а также добавление и удаление пользователей в сегмент)

**Основное задание (минимум):**

1. Метод создания сегмента. Принимает slug (название) сегмента. 
2. Метод удаления сегмента. Принимает slug (название) сегмента. 
3. Метод добавления пользователя в сегмент. Принимает список slug (названий) сегментов которые нужно добавить пользователю, список slug (названий) сегментов которые нужно удалить у пользователя, id пользователя.
4. Метод получения активных сегментов пользователя. Принимает на вход id пользователя.

**Детали по заданию:**

1. По умолчанию сервис не содержит в себе никаких данных о сегментах и пользователях (пустая табличка в БД). Данные появляются при создании сегментов и добавлении их пользователям.
2. Валидацию данных и обработку ошибок оставляем на ваше усмотрение.
3. Список полей к методам не фиксированный. Перечислен лишь необходимый минимум. В рамках выполнения доп. заданий возможны дополнительные поля.
4. Механизм миграции не нужен. Достаточно предоставить конечный SQL файл с созданием всех необходимых таблиц в БД.
5. Сегменты пользователя очень важны - на этих данных в будущем строится аналитика о том насколько продукт востребован. Поэтому нужно следить за тем чтобы сегменты не терялись (не перетирались) и не добавлялись лишним пользователям.
6. Мы можем добавлять сегменты пользователю динамически (он уже состоит в нескольких, мы можем добавить еще несколько, не перетирая существующие).
7. В методе получения сегментов пользователя мы должны получить АКТУАЛЬНУЮ информацию о сегментах пользователя с задержкой не более 1 минуты после добавления сегмента.

**Технические требования:**

1. Сервис должен предоставлять HTTP API с форматом JSON как при отправке запроса, так и при получении результата.
2. Язык разработки: Golang.
3. Фреймворки и библиотеки можно использовать любые.
4. Реляционная СУБД: MySQL или PostgreSQL.
5. Использование docker и docker-compose для поднятия и развертывания dev-среды.
6. Весь код должен быть выложен на Github/Gitlab с Readme файлом с инструкцией по запуску и примерами запросов/ответов (можно просто описать в Readme методы, можно через Postman, можно в Readme curl запросы скопировать, и так далее).
7. Если есть потребность в асинхронных сценариях, то использование любых систем очередей - допускается.
8. При возникновении вопросов по ТЗ оставляем принятие решения за кандидатом (в таком случае в Readme файле к проекту должен быть указан список вопросов, с которыми кандидат столкнулся и каким образом он их решил).
9. Разработка интерфейса в браузере НЕ ТРЕБУЕТСЯ. Взаимодействие с API предполагается посредством запросов из кода другого сервиса. Для тестирования можно использовать любой удобный инструмент. Например: в терминале через curl или Postman.

### Доп. задача: 
*Доп. задание 1:*

Задача: реализовать сохранение истории попадания/выбывания пользователя из сегмента с возможностью получения отчета по пользователю за определенный период. На вход: год-месяц. На выходе ссылка на CSV файл.

Пример отчета:

идентификатор пользователя 1;сегмент1;операция (добавление/удаление);дата и время

идентификатор пользователя 1;сегмент2;операция (добавление/удаление);дата и время

идентификатор пользователя 2;сегмент3;операция (добавление/удаление);дата и время

## Реализация
### Файловая система и файлы
* app - db - Файлы с функциями запроса к БД
* app - handler - Файлы с функциями заголовков
* app - helper - Файл с кодом обработчика ответов
* app - init - SQL файл начальной инициализации БД
* app - entrypoint.sh - Срипт для билдинга

### Запуск
1. Меняем файл .env под свою конфигурацию
2. Меняем порт в файле main.go, если 8080 занят
3. Делаем постройку образов Docker без использования кэша
   
   ```sh
   docker compose build --no-cache`
   ```

5. Поднимаем контейнеры

   ```sh
   docker compose up -d
   ```

7. Делаем запросы через Postman

### Примеры запросов/ответов 
#### Основное задание
В случае удачного или неудачного запроса возвращается JSON в формате 
  ```JSON
  {
    "message": "Message",
    "code": 000
  }
  ```
* Метод создания сегмента
  
  Запрос GET: http://localhost:8080/segments/create/{name}
  
  Ответ:

  ```JSON
  {
    "message": "Successful add",
    "code": 200
  }
  ```
  
* Метод удаления сегмента
  
  Запрос GET: http://localhost:8080/segments/delete/{name}

    Ответ:

  ```JSON
  {
    "message": "Successful del",
    "code": 200
  }
  ```
* Метод добавления пользователя в сегмент

  Запрос PUT: http://localhost:8080/compliances/{id_user}/segments
  
  Тело:

  ```JSON
  {
    "added": ["AVITO_DISCOUNT", "AVITO_DISCOUNT_30"],
    "deleted":["AVITO_DISCOUNT_50"]
  }
  ```
   Ответ:
  
  ```JSON
  {
    "message": "Successful add / del / add and del",
    "code": 200
  }
  ```
* Метод получения активных сегментов пользователя

   Запрос GET: http://localhost:8080/compliances/{id_user}

   Ответ:
  
  ```JSON
  [
    {
      "id_user": 147,
      "name_segment": "Test!"
    }
  ]
  ```

* Метод получения активных сегментов
  
   Запрос GET: http://localhost:8080/compliances

   Ответ:
  
  ```JSON
  [
    {
      "id_user": 147,
      "name_segment": "Test!"
    }
  ]
  ```
  
* Метод получения сегментов

  Запрос GET: http://localhost:8080/segments

  Ответ:
  
  ```JSON
  [
    {
      "name_segment": "Test!"
    }
  ]
  ```
#### Доп. задача:
  
* Метод получения .csv файла

  Запрос GET: http://localhost:8080/history

  Ответ: output.csv файл
  
